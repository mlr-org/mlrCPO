# RetrafoState.R provides functionality for inspecting the state of a Retrafo
# object, and reconstructing a Retrafo object with a modified state.

#' @title Get the Internal State of a CPORetrafo Object
#'
#' @description
#' A \code{\link{CPORetrafo}} always has access to some kind of state
#' that represents information gotten from the training data,
#' as well as the parameters it was called with.
#'
#' Only primitive \code{\link{CPORetrafo}} objects can be inspected like this.
#' If the supplied \code{\link{CPORetrafo}} is not primitive, split it into
#' its constituents using \code{\link[base:list]{as.list}}.
#'
#' The structure of the internal state depends on the \code{\link{CPO}} backend
#' used. For Functional CPO, the state is the environment of the
#' retrafo function, turned into a list. For Object based CPO,
#' the state is a list containing the parameters, as well as the
#' control object generated by the trafo function.
#'
#' The object can be slightly modified and used to create a new
#' CPORetrafo object using \code{\link{makeRetrafoFromState}}.
#'
#' @param retrafo.object [\code{CPOTrained}]\cr
#'   The object to get the state of.
#' @return [\code{list}]. A named list, containing the complete internal state of the \code{\link{CPOTrained}}.
#' @family state functions
#' @family retrafo related
#' @family inverter related
#' @export
getRetrafoState = function(retrafo.object) {
  UseMethod("getRetrafoState")
}


# RETRAFO State
# The state is basically the control object, or the trafo-function's environment
# We also keep the shapeinfo.input and shapeinfo.output information
#' @export
getRetrafoState.CPOTrainedPrimitive = function(retrafo.object) {
  if (is.nullcpo(retrafo.object)) {
    return(NULL)
  }
  cpo = retrafo.object$cpo
  otype = getCPOObjectType(retrafo.object)
  if (otype != "CPORetrafo") {
    stopf("Cannot get state of %s", otype)
  }
  assertChoice(cpo$control.type, c("functional", "object"))
  if (cpo$control.type == "functional") {
    res = as.list(environment(retrafo.object$state))
    if (!"cpo.retrafo" %in% names(res)) {
      res$cpo.retrafo = retrafo.object$state
    } else if (!identical(res$cpo.retrafo, retrafo.object$state)) {
      stopf("Could not get coherent state of CPO Retrafo %s, since 'cpo.retrafo' in\n%s",
        cpo$debug.name, "the environment of the retrafo function is not identical to the retrafo function.")
    }
  } else {  # cpo$control.type == "object
    res = getBareHyperPars(cpo)
    res$control = retrafo.object$state
  }
  # c() to drop the retrafo.object's class
  res$data = c(retrafo.object[c("shapeinfo.input", "shapeinfo.output")])  # nolint
  res
}

#' @export
getRetrafoState.CPOTrained = function(retrafo.object) {
  stop("Cannot get state of compound retrafo. Use as.list to get individual elements")
}


# rebuilds a retrafo object from a given state. It does that by
# constructing a "bare" (empty) retrafo object and fills in the missing slots.
#' @title Create a CPORetrafo with Given Internal State
#'
#' @description
#' This creates a new \code{\link{CPORetrafo}} object which will
#' behave according to the given state. The state should usually be obtained using
#' \code{\link{getRetrafoState}} and then slightly modified. No checks for correctness
#' of the state will (or can) be done, it is the user's responsibility to ensure
#' that the correct \code{\link{CPOConstructor}} is used, and that the state is
#' only modified in a way the CPO can handle.
#'
#' @param constructor [\code{\link{CPOConstructor}}]\cr
#'   A cpo constructor.
#' @param state [\code{list}]\cr
#'   A state gotten from another CPO retrafo object using
#'   \code{\link{getRetrafoState}}.
#' @return [\code{CPORetrafo}]. A CPORetrafo (as if retrieved using \code{\link{retrafo}} after
#'   a primitive \code{\link{CPO}} was applied to some data) with the given state.
#' @family state functions
#' @family retrafo related
#' @family inverter related
#' @export
makeRetrafoFromState = function(constructor, state) {
  assertClass(constructor, "CPOConstructor")
  assertList(state, names = "unique")
  bare = constructor()

  data = state$data
  state$data = NULL
  assertSetEqual(names(data), c("shapeinfo.input", "shapeinfo.output"))

  assertChoice(bare$control.type, c("functional", "object"))
  if (bare$control.type == "functional") {
    assertSubset("cpo.retrafo", names(state))
    bare$par.vals = list()

    newstate = state$cpo.retrafo
    # update newstate's environment to actually contain the
    # values set in the 'state'
    env = new.env(parent = parent.env(environment(newstate)))
    list2env(state, envir = env)
    environment(newstate) = env
    # also set the 'cpo.retrafo' in the env to point to the current 'newstate' function.
    # if we did not do this, the 'cpo.retrafo' variable visible to newstate would
    # be the same function *but with a different environment* -- recursion would break
    # (this is because of 'environment(newstate) = env' above)
    env$cpo.retrafo = newstate
  } else {  # bare$control.type == "object
    assertSubset("control", names(state))
    newstate = state$control
    state$control = NULL
    bare$par.vals = state
    assertSubset(names(bare$par.vals), names(bare$bare.par.set$pars))
    if (length(state)) {
      names(bare$par.vals) = paste(bare$id, names2(bare$par.vals), sep = ".")
    }
  }

  makeCPORetrafo(bare, newstate, NULL, data$shapeinfo.input, data$shapeinfo.output)
}
